前端的代码实现是个典型的Vue应用：

#### 项目入口：main.js。

#### 数据层/状态管理：store目录。

为了使系统结构清晰，我把所有数据层的内容全部集中封装在了一起，全都写在了基于<u>VueX</u>的状态管理仓库中，不光所有的应用数据都放在了store中，数据的初始化获取、各请求后端的业务实现全都放在了store中。

UI层通过触发action事件并传递参数，由Vuex在各个action中监听这些事件，完成相应的业务操作、更新数据层，然后再将执行的结果返回给UI层。

store内部根据业务分类，被拆成一个个模块，一起装入index.js中，对外暴露一个唯一的store实例，挂载到VueApp。

#### 网络Api：api目录。

在数据层的基础上，将其中需要发起请求、与服务端交互的部分抽离出来，封装成专门的方法，放在api层。使用<u>Axios.js</u>库来简化网络请求的处理。

api内部根据业务分类，被拆成一个个模块。其中index.js是对整个api层的一些设置，例如baseUrl、拦截器等。

- 在请求拦截器中为所有请求加上token(如果有的话)。
- 在响应拦截器集中处理各种异常响应：根据响应中的statusCode和message对错误响应并通知用户。如果请求成功则将响应体中的data返回。

#### UI层：App.vue、views目录、components目录、assets目录。

- App.vue：整个页面的入口，由他来引用各个页面。

- views目录：核心的视图层，对应着每个页面的具体实现。
- components目录：视图组件，这里封装着在多个视图中会重复用到的一些页面元素。
- assets目录：用于构建页面的一些静态资源，如图片、字体库、CSS等。

正如前面所提到的，业务的核心部分，全都被拆分抽离，放在了数据层——store的action中。UI层中只有纯视图的部分：

- 编写静态页面；

- 从数据层拿数据，利用Vue响应式地渲染到页面；

- 实现一些动画、特效；

- 处理用户交互

  - 一方面是纯视图层的用户操作，例如拖拽某个窗体、在浏览文章时点击“返回顶部”按钮。

  - 另一方面则是涉及到表单的提交，像服务端发起请求，这涉及数据交互，此时只做两件事：

    - 对用户的输入进行校验。

    - 触发相应业务事件，附上用户输入，交由数据层来完成；根据数据层执行完毕后返回的结果，在视图层上给予用户一些反馈。

#### 路由：router目录。

通过Vue-Router完成路由管理，定义Url与页面的对应关系、页面的隶属嵌套关系、以及规定某些情况下页面跳转的路由守卫等。

#### utils目录

对某些可复用逻辑的封装。一般起工具作用，与业务关联不大。

#### 系统常量：constant目录

对系统需要用到的一系列常量的抽象，让用到常量的地方去访问抽象命名而非值本身。解耦，且使代码更易读。

#### 界面视觉效果：~~Element Plus~~ 纯原生

为了消除UI库对实现某些特定效果，以及供大家做个性化界面定制带来的麻烦与干扰，本系统不准备引入任何外部的UI库，而是通过纯原生css、js的方式来实现页面效果。

但因为目前处于开发初期，为了提升效率，减少对其他业务内容开发的干扰、不拖慢开发进度（毕竟一个CSS能调一天，UI是个大工程），暂时引入了Element Plus，怎么快捷怎么来，界面会很丑。随着后面系统完成度的提升，Element Plus会被逐步弃用，一点点替换为纯原生实现。