# 边界情况

接口调用方的参数总是有着各种可能，这方面的需求是无限的，在编写代码的时候不可能全顾及到，该如何校验，遵循这样的规则：

对于不会导致服务器错误、破坏系统的边界情况，就不需要校验。<br>这种边界情形，不会导致服务端崩溃，也不会导致业务出现致命错误，往往是一些在客户端能看到自己这种操作反馈的小错误。只需要用户撤销自己的操作重做即可。<br>这些情形如果全部校验，开发效率会很低，代码也会很冗长臃肿。

还有些情况，可以通过一些简单的转换，替调用方将参数转换成正常参数。

> 下面的文档中，谈及边界情况，主要是描述业务层面上的边界情况，至于类型检查、取值范围这类琐碎且显而易见的，不赘述，在代码中一望便知。

# 资源模块

### 业务要点

网站中各种形式的内容，都由资源模块提供。资源按类别保存在本地文件系统中，结构如下：

- data //根目录

  - resource //各资源

    - content //内容

      内部可为层层嵌套的多层结构，每层都遵循下面结构。

      内容包括三类：

      1. 图文.md
      2. HTML片段.html
      3. 导图.json

      除此之外还有：

      4. _catalog.json //后文的组织结构模块会有详细定义。

    - htmlPlugin //HTML插件

      单层结构，存储了各HTML插件内容

    - pic //图片等非文字媒体资源

      内部可为层层嵌套的多层目录。

    - file //文件

      内部可为层层嵌套的多层目录。

  - bin //回收站

    相比resource中各资源目录内的嵌套结构，bin下各资源回收站目录内都是单层结构，所有的资源被放入回收站后都是被放在同一级中。

    这可能会产生命名冲突，所以还会包含一个配置文件，用来记录各文件删除前的名字和当前名字的对应。除此之外这个配置文件还会记录删除时间、删除文件的用户等一系列和删除有关的信息。

    - content
      1. 各被删除文件。
      2. _catalog.json
    - htmlPlugin
      1. 各被删除文件。
      2. _catalog.json
    - pic
      1. 各被删除文件。
      2. _catalog.json
    - file
      1. 各被删除文件。
      2. _catalog.json

  - site //网站信息

    - footer.json //页脚配置
    - site.json //其他网站信息

  - db.sql //sqlite的数据库文件

系统数据的根目录路径储存在项目目录的package.json中，每次获取资源从这个位置拿到前缀路径，和相对路径拼接构成定位资源的绝对路径。

系统的全部数据按照上面的方式保存，使得：

1. 以独立性较高的形式承载内容。
   - 数据不借助该系统也能够独立具有接近于用户所创作内容的语义；
   - 能够轻松的根据现有的数据开发一个新的类似系统，兼容这些数据；
   - 数据能够轻松的导入导出，实现迁移、备份。
2. 能够通过一些文件同步应用，如FreeFileSync或Git，在任何一台电脑拷贝副本、维持系统和任意主机之间的内容同步，无需登入系统就能在本地完成内容的编辑、组织，只需时候同步即可，以此增强分布式资源管理。

### 模块初始化

在模块service的构造函数中，进行初始化，完成以下工作：

1. 初始化资源目录

   数据目录是否可达？→

   - 不可达则将路径修改为默认路径(和应用同一级创建data目录)并在对应位置创建data目录→
     - 创建时检测默认位置data名称是否已被占用，若占用询问用户是否删除原目录→
   - 检测当前路径指向的是目录还是文件，如果是文件则提示用户名称已被占用，是否删除原文件→

   目录内各子目录、文件是否存在？不存在则执行创建→

   目录内各子目录、文件是否被同名文件、目录占用？冲突则删除后创建→

2. 初始化HTML插件缓存

   将各HTML插件内容载入缓存→

   监听htmlPlugin目录——当HTML插件产生更改时刷新缓存→

### 各功能接口设计

#### 资源内容获取 | /resource/get

功能：根据请求参数中的相对路径与资源类型，读取对应资源内容返回。

边界情况：

1. 相对路径最终的实际触达位置，在所请求类型的资源根目录的外部。后文统称“请求路径越界”。
2. 请求路径不可达。
3. 不鉴别路径是文件还是文件夹。无需校验，因为这对服务端不会产生任何影响，而客户端能识别并拦截这种情形。

代码执行流程：

1. controller层：校验路径是否越界→调用service层→将结果生成响应体返回。
2. service层：按请求文件的类型去对应目录读取文件内容→若是图文资源，则给相应资源对应的图文浏览量+1→将内容返回。期间要捕获可能出现的异常：路径不可达。

#### 资源列表获取 | /resource/list

功能：根据请求参数中的相对路径和资源类型，返回该目录下的资源列表。

边界情况：

1. 请求路径越界。
2. 路径不可达。
3. 相对路径指向的是一个文件而不是目录。无需校验，因为这对服务端不会产生任何影响，而客户端也不会发来这种请求。

业务要点：

资源不同，查询列表的方式也不同，如果是要查询回收站下某个类型的回收文件，则需要到对应的目录找到配置文件，将配置文件中有关原文件、现文件名等信息的列表读出；如果是查询html插件，则返回的不是文件列表，而是这些插件内容的列表，直接从缓存中读出并返回；剩余资源则才是调用文件系统接口，读取目录下的资源列表。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果生成响应体返回。
2. service层：按资源类型读取目录→将内容返回。期间要捕获可能出现的异常：路径不可达。

#### 资源下载 | /resource/download

功能：根据请求参数中的相对路径和资源类型，提供该资源的下载。

边界情况：

1. 请求路径越界。
2. 路径不可达。
3. 所请求下载的资源不是文件是目录。（目前的实现还未支持目录下载）

业务要点：

目前的实现是快速迭代时的权宜之计——通过express的download方法以下载的方式向调用方发送文件。但问题是express的download方法限制颇多：

1. 不支持目录下载。

2. 只支持以回调的方式处理错误，try catch是捕获不到异常的，这就导致处理一些业务上的错误不便。

3. 就算是在回调处理错误，他提供的异常对象err，也不是常规的Error对象，而是一些莫名其妙的字符串(name, message, stack)，并且对于不同类型的错误，这个错误对象还大不相同。

   这就意味着根本没办法根据错误码来检测错误，错误处理完全不可控，没办法在回调处理。

   同时在回调抛出来也是无法实现的，因为根本抛不出来，经测试发现这种做法没反应。

   所以就只能尽可能预料到各种错误，然后在调用这个方法之前检查这些情形，至于其他的错误，不做任何处理、不写回调。似乎express和nest之间有一种内部的机制，express的这个方法出错，在没有回调的情况下，nest是能检测到的，并且会返回给客户端一个简单的错误信息。

代码执行流程：整个流程都在controller中，因为是直接调express的方法，所以不涉及service层。

1. 检查路径是否越界。
2. 检查路径可达性。
3. 检查路径是否指向了目录。
4. res.download()。

#### 资源上传 | /resource/upload

功能：根据请求资源和类型，(批量)将资源保存至服务器。

边界情况：

1. 请求路径越界。
2. 路径不可达。

业务要点：

如果目标位置已经存在同名文件，会被覆盖。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果生成响应体返回。
2. service层：按资源类型将上传文件(批量)写入目标目录。期间要捕获可能出现的异常：路径不可达。

#### 新建目录 | /resource/createCatalog

功能：根据参数中资源类型、相对路径、目录命名，在指定位置按照命名新建一个目录。

边界情况：

1. 请求路径越界。
2. 路径不可达。
3. 目录命名已存在。

业务要点：

对已存在该名称情形的处理，思路同上。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果生成响应体返回。
2. service层：检查名称是否存在，存在则寻找一个可用的相似名称→创建目录→返回结果。期间要捕获可能出现的异常：路径不可达。

#### 新建内容 | /resource/createFile

功能：以新建而非上传的方式，在content目录中新增一个内容文件。对应了用户使用在线编辑器创作内容的情景。

边界情况：

1. 请求路径越界。
2. 路径不可达。
3. 文件命名已存在。

业务要点：

如果请求中新内容文件的命名已经存在，则会导致错误，所以就需要用前缀路径和该命名拼接后检查可达性，若可达则证明已有该文件，但不向客户端抛出错误，而是用一个相近且不存在的名称创建后告知用户。

具体实现就是，只要前缀+命名拼接出的路径可达，就给命名后面拼接“(1)”，再次验证，循环往复。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果生成响应体返回。
2. service层：检查名称是否存在，存在则寻找一个可用的相似名称→创建文件（期间要捕获可能出现的异常：路径不可达）→将结果生成响应体返回。

#### 编辑内容 | /resource/update

功能：对内容资源这一类型资源中的某内容进行更新。对应了用户使用在线编辑器编辑内容的场景。

边界情况：

1. 请求路径越界。
2. 路径不可达。
3. 路径的上一级可达，即该名称文件不存在。
4. 路径指向的是目录。

业务要点：

文件系统的writeFileSync接口，可以在不存在该名称的情况下按照内容和名称新建，存在的情况下按照内容和名称覆盖，所以对于边界情况中，路径上一层可达，只是文件名不存在的情况，也是能够应对的。只需要在执行指出检测出这种情形，并报告给调用方即可。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果生成响应体返回。
2. service层：检查该名称文件是否存在→在对应路径文件写入内容（期间捕获异常：路径不可达、路径指向的是目录）→将结果生成响应体返回。

#### 重命名资源 | /resource/rename

功能：对路径指向的文件或目录重命名。

边界情况：

1. 请求路径越界。
2. 路径不可达。
3. 名称已存在。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果生成响应体返回。
2. service层：重命名路径指向资源（期间捕获异常：路径不可达、已存在该名称）→返回。

#### 删除资源 | /resource/delete

功能：删除指定路径资源。

边界情况：

1. 请求路径越界。
2. 路径不可达。

业务要点：

1. 系统设有回收站。删除是先将资源删除到回收站，所以删除分两种：普通删除与永久删除，前者对应的操作为在相应资源目录下找到资源移动到回收站目录中相应资源的目录下，后者是在回收站相应资源类型的目录下找到并永久删除。

   删除时，特定类型的资源都会被丢弃到同一个同级别的回收站目录，就像Windows系统的回收站那样。这就意味着会有重名文件。对于名称冲突的情况，处理思路和前面提到的新建文件时名称已存在情形的处理思路相同，<br>但除此之外，需要一个配置文件，来记录文件原名，和在回收站中名称的对应关系，方面使用者了解情况、恢复文件。

2. 目前存在的一个问题：

   按照上面的分析，这两种删除都包含了两个步骤，一个是移动/删除文件，在这之后对配置文件进行修改，新增或移除对应条目。

   那么如何保证这两件事的一致性就成了问题，有可能第一个操作执行后，第二个操作执行因为某种意外问题失败了，这样一来资源已经产生了更改，但因为记录删除情况的配置文件没变动，客户端看到的回收站列表就是错的，这可能就会引起进一步的错误。

   但文件操作并没有封装好的事务接口，目前对这种情形没有做预防。虽然概率很小，但还是有可能发生。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果生成响应体返回。
2. service层：根据删除类型执行移动或移除文件的操作（期间捕获可能出现的异常：路径不可达）→修改回收站目录下对应资源类型目录中的配置文件，记录删除→返回。

#### 恢复已删除资源 | /resource/recovery

功能：按回收站中的文件名指定，将回收站资源恢复到删除前位置。

边界情况：

1. 文件名导致路径越界。
2. 回收站不存在该文件。
3. 该文件原位置已经不存在。
4. 该文件原位置已有同名文件。

业务要点：

1. 和删除资源一样，恢复资源也是两个步骤，一是将文件移回去，二是修改回收站相应记录。所以和前面一样，也存在这两个步骤的一致性问题。
2. 由于某些意外，可能在配置文件中找不到有指定文件的记录，但指定文件确实在回收站中存在，这种情形则将该文件恢复到对应类型资源的根目录下。
3. 将文件复原时，原路径可能已经存在该名称，对命名冲突的情形，解决思路同前面“新建内容”功能一样。
4. 这四种边界情况要注意处理顺序，因为有些情形并不需要另一些情形的明确作为前置条件，有些则反之。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果返回。
2. service层：先按照请求中的文件名在配置文件中查找是否存在相关记录，生成对应的原始/恢复路径→确保原始路径不可达/不重名→移动文件（期间捕获可能出现的异常：回收站中并不存在该名称文件）→将结果生成响应体返回。

#### 复制资源 | /resource/copy

功能：复制资源到指定路径（文件目录均可）。

边界情况：

1. 请求路径越界。
2. 命名已存在。
3. 路径不可达（资源路径和目标路径）。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果返回。
2. service层：确保目标路径命名不冲突→复制资源（期间捕获可能出现的异常：路径不可达）→将结果生成响应体返回。

#### 移动资源 | /resource/cut

功能：移动资源到指定路径（目录文件均可）。

边界情况：

1. 请求路径越界。
2. 命名已存在。
3. 路径不可达（资源路径和目标路径）。

代码执行流程：

1. controller层：校验请求路径是否越界→调用service层→将结果返回。
2. service层：确保目标路径命名不冲突→移动资源（期间捕获可能出现的异常：路径不可达）→将结果生成响应体返回。

#### 数据导出 | /resource/export

功能：将网站全部数据打包导出，发送给调用方。

业务要点：

express的文件传输功能发不了文件夹，要先借助库compressing生成压缩文件再发送。

代码执行流程：整个流程都在controller中。

1. 在数据目录的根目录同级生成数据目录的压缩文件。
2. 利用res.download发送，在回调函数中将该临时文件删除。

#### 数据导入 | /resource/import

功能：按指定路径将数据导入，作为网站新的数据源。

业务要点：

1. 具体来说是用户上传一个数据目录的压缩包（因为没办法传文件夹），然后由服务端解压到目标路径。数据文件夹的根目录需要命名为data（约定，统一命名能减少很多工作），其他名称识别不了。所以如果所指定路径已经存在名为data的目录，会被覆盖。

1. 数据导入到服务器的位置可以有使用者自行指定，也可以空置默认为原来的位置。
2. 数据导入后需要刷新缓存，将缓存的各数据更新。

代码执行流程：

1. controller层：确认目标路径为空或可达→调用service层→调用网站管理模块的service层刷新缓存→将结果生成响应体返回。
2. service层：将文件解压到指定路径→如果是新路径，刷新网站数据存储根路径→返回。

# 动态模块

### 数据库表

在数据库通过Post表存储动态信息：

| 名称       | 所记录信息   | 类型         | 约束                 | 备注                                                         |
| ---------- | ------------ | ------------ | -------------------- | ------------------------------------------------------------ |
| id         | 唯一标识     |              | 主键、自增、唯一     |                                                              |
| content    | 动态内容     |              |                      |                                                              |
| pic        | 动态配图     | simple-array |                      | 是一个字符数组，存储了图片的相对路径。                       |
| time       | 发表时间     | string       | @CreateDateColumn()  | 通过左边的注解，该项是随着数据库记录的创建，根据当时时间自动生成的。 |
| timeUpdate | 上次编辑时间 | string       | @UpdateDateColumn(0) | 通过左边的注解，该项是随着数据库记录的更改，根据当时时间自动生成，覆盖写入。 |
| views      | 浏览次数     | int          | 默认为0              |                                                              |
| del        | 逻辑删除标志 | int2         | 默认为0              |                                                              |

### 各功能接口设计

#### 动态列表 | /post/list

功能：根据分页参数和过滤器加载动态返回。过滤器为两个可选的参数：起始时间、截至时间。

业务实现要点：

1. 动态列表是懒加载的，在服务端的角度看就是分页，每次请求特定范围的动态，经过筛选过滤器之后，从指定位置读取指定条数。

2. 获取动态，对应的用户事件是浏览动态，所以对于被获取的动态条目，需更新对应条目的浏览次数。

代码执行流程：调用service层先拼接查询语句，再在数据库查，最后对查出来的条目更新浏览量→返回读取结果(controller)。

#### 发表动态 | /post/create

功能：新增一条动态。

代码执行流程：调用service层在数据库增(service)→返回成功信息(controller)。

#### 编辑动态 | /post/update

功能：修改动态信息。

代码执行流程：调用service层在数据库改(service)→返回成功信息(controller)。

#### 删除动态 | /post/delete

功能：删除动态信息。

代码执行流程：调用service层在数据库逻辑删(service)→返回成功信息(controller)。

# 权限、用户管理模块

### 业务要点

这里的核心主要在鉴权，鉴权分两个层面，

- 身份核实

  - 账号密码登录。

  - 已经登录后记录登录信息，自动登录。自动登录通过jwt来实现。

    - 生成签发一个token，将这个token设置在客户端的cookie中，客户端每次发起请求的时候把token放在名为Authorization的头信息中，由后端校验。

    - payload里要包含登录用户的id，这样才能知道是谁登录。

    - payload里还要包含token的签发时间，这样就可以通过比对签发时间和当前时间，确认token是否过期。（当然给前端的cookie依然要设置过期时间。）

      还要给用户表中增加一个expire字段，含义为截至至expire以前的token都作废。这样通过刷新这个字段，校验的时候检查签发日期一定要大于expire，就可以手动让先前签发的token都作废过期。

- 权限系统

  遵循用户→角色→权限。某个用户具备某个角色，某个角色具备一系列操作的权限。

  访问某些特定功能的时候，在检查登录状态之后，就要检查这个用户是否具备该操作的权限。

  目前的权限管理粒度很粗，很多东西都是写死的，只能进行有限的管理：

  - 系统都有哪些权限是写死的，只有几个特定模块的权限可选：

    ```javascript
    [
        {
            name: 'PostW',
            comment: '动态写'
            //网站浏览者可以读所有动态，所以读权限默认都有。
        },{
            name: "ResourceR",
            comment: "资源读"
        },{
            name: "ResourceW",
            comment: "资源写"
        },{
            name: "StructureW",
            comment: "组织结构写"
            //网站浏览者可以读所有网站结构。所以读权限默认都有。
        },{
            name: "SiteR",
            comment: "站点信息读"
        },{
            name: "SiteW",
            comment: "站点信息写"
        },{
            name: "UserR",
            comment: "用户信息读"
            //User对应了网站鉴权相关的权限管理，包括角色管理、用户管理。如下面所述，管理的权限只有超管有，所以存在，但对任何用户提供UserW写权限，只校验是否为超管。
        }
    ]
    ```
  
  - 角色可以自由创建，可以自行管理角色都有哪些权限。
  
    但角色和用户写的权限是写死的，只能由系统初始的超级管理员完成。

本系统控制台不支持多设备登录，只支持单一地点登录，新的登录会导致所有旧登录失效。

### 数据库表

在数据库通过User表存储用户信息：

| 名称     | 所记录信息                                     | 类型 | 约束             |
| -------- | ---------------------------------------------- | ---- | ---------------- |
| id       | 唯一标识                                       |      | 主键、自增、唯一 |
| username | 用户名                                         |      | 唯一             |
| password | 密码                                           |      |                  |
| role     | 角色                                           |      |                  |
| expire   | token过期分界，是个时间戳，用来使一些token过期 | int  | 默认0            |

在数据库通过Role表存储角色信息：

| 名称     | 所记录信息 | 类型         | 约束             |
| -------- | ---------- | ------------ | ---------------- |
| id       | 唯一标识   |              | 主键、自增、唯一 |
| rolename | 角色名     |              | 唯一             |
| claims   | 权限列表   | simple-array |                  |

### 模块初始化

在模块service的构造函数中，进行初始化，完成以下工作：

1. 初始化根用户：去数据库检查根用户是否存在，若不存在，则在命令行指引用户输入信息完成根用户的初始化，根据用户输入在数据库创建根用户。

### 各功能接口设计

#### Authentication-用户登录 | /user/login

功能：校验用户账户密码正确与否。

- 成功：为客户端在cookie设置token；令所有旧token失效；返回用户信息。
- 失败：告知客户端登录失败。

业务实现要点：

1. 该功能没有走常规的controller->service->database实现，是直接交由系统的鉴权守卫LocalStrategy实现。

2. 密码有加密，用bcrypt检验。

3. 返回的用户信息不能直接从payload里去，因为有可能是旧的，要用payload的id去数据库查用户信息。

4. 设置token是在相应拦截器里实现的，因为nest的守卫无法设置cookie。

   在拦截器中统一判断，判断context中有没有user，有user就说明通过了鉴权，要么通过了登录，要么通过了jwt校验，总有一种，而这两种情形的处理是通用的，因为都是做刷新设置cookie的操作。

5. 令可能存在的旧token失效。因为这是个管理员系统，为了安全起见，假设不希望多设备同时登录，所以新的登录会刷新过期状态，使得旧的token过期。具体实现也颇为简单，直接调用service层的quit(登出)功能即可。

5. 密码不能为空，这并不是出于业务的考量，而是使用的passport库不支持，他的local策略在password为空的情况下会直接返回错误。翻遍nest和passport的文档也没有找到放开这一限制的选项。

代码执行流程：

- 成功：检验密码是否正确(local守卫)→读取用户信息并放入context(local守卫)→令先前token失效(controller调用service)→发送带有用户信息的成功响应(controller)→刷新token设置在cookie中(响应拦截器)。
- 失败：检验密码是否正确(local守卫)→抛出相应业务异常-这里是直接返回false即可(local守卫)。

#### Authorization-特定功能检查登录状态、所需要权限 | Header-Authorization

这是一个通用功能，是很多其他功能的前置流程。在其他涉及该功能使用的地方不再重复。

功能：在调用需要鉴权的方法时，先核验token有效性，再确认是否具备相应操作权限，最后在返回结果之前为客户端刷新token时间完成续签。

- 成功：进入到原本要访问的接口，并且在响应之前设置好cookie，刷新token。
- 失败：直接抛出各种对应的业务异常，例如401 Unauthorization和403 Forbidden。

业务实现要点：

1. 该功能没有走常规的controller->service->database实现，是直接交由系统的鉴权守卫JwtStrategy实现。

   该守卫被注册为全局默认守卫。对于需要其他守卫或无需鉴权的接口，通过注解来覆盖；对于需要某特定权限的接口，通过注解来标识。

2. 检查注解，如果是Public公共接口，则直接返回成功。

   该守卫先继承自passport-jwt守卫，根据预设完成对jwt本身有效性的校验。

   然后根据payload中的id拿到完整的用户信息，放入context中。

   根据payload中的签发日期，比对从数据库中查到的上次过期时间，确认此token没有过期。

   根据用户信息中的角色、角色具备的权限，判断是否具备访问某接口的权限。

   ----------此时守卫的工作已经完成----------

   通过响应拦截器拦截所有响应，检查context中是否存在用户信息，如果存在就说明通过了Authentication的passport-local账号密码校验，或者通过了Authorization的passport-jwt令牌校验，这就需要更新token，给token续期，此时重新生成一个token设置到cookie中。

   又因为如果鉴权失败会直接抛出异常，代码进入filter层，根本不进入interceptor层(不刻意捕捉得话)，所以就算jwt基本有效性检验通过后面的检验失败，用户信息被误放入context中，也会因为没有进入响应拦截器而被忽略。

#### Authorization-自动登录 | /user/autoLogin

功能：用户进入应用时，在有token的情况下，客户端自动校验登录状态完成登录。

- 成功：返回用户信息。
- 失败：告知客户端token已经失效。

业务实现要点：

1. 整个过程什么也不做，就是自动通过上面的功能去校验，要是token无效就会发生异常，要是有效就会匹配到对应路由，直接在路由返回用户信息即可。

代码执行流程：

- 成功：检验token(Jwt守卫)→读取用户信息并放入context(Jwt守卫)→发送带有用户信息的成功响应(controller)→刷新token设置在cookie中(响应拦截器)。
- 失败：检验token(Jwt守卫)→抛出相应业务异常-这里是直接返回false即可(Jwt守卫)。

#### Authorization-退出登录 | /user/quit

功能：作废原先所有的token。

业务实现要点：

1. 注意这里除了要让token过期，还要阻止拦截器发新的token。因为这个操作是需要鉴权的，而根据前面的有关鉴权功能的设计，对于需要鉴权且通过了鉴权的操作，最后都会签发新的token续期。这里既然已经是退出，就不能再发新的token了。所以签发token的拦截器里要先检查请求路径是否为/user/quit，如果是就直接clearCookie。

代码执行流程：令所有之前的token失效(controller调用service)→发送成功响应(controller)。

#### 密码修改 | /user/updatePassword

功能：修改用户的密码；作废原来的token。

业务实现要点：

1. 因为守卫的鉴权已经验明身份了，所以根本不用校验什么原密码，直接接收个新密码更新即可。
2. 密码要加密。

代码执行流程：调用service层刷新密码和过期时间(service)→返回成功信息(controller)。

#### 获取角色列表 | /user/listRole

功能：获取角色列表。

代码执行流程：调用service层在数据库读(service)→返回读取结果(controller)。

#### 新增角色 | /user/createRole

功能：新增角色。

边界情况：

- 角色名称不能为super。

- 不能和已经存在了的名称冲突。

代码执行流程：调用service层在数据库增(service)→返回成功信息(controller)。

#### 编辑角色 | /user/updateRole

功能：修改角色信息。

边界情况：

- 角色名称不能为super。
- 不能和已经存在了的名称冲突。

代码执行流程：调用service层在数据库改(service)→返回成功信息(controller)。

#### 删除指定角色 | /user/delRole

功能：删除指定名称角色。若该角色正在被引用则返回错误。

边界情况：

- 执行删除流程时，要先去user表检查有没有用户当前权限为被删除权限，有则抛出异常。

代码执行流程：调用service层在数据库删(service)→返回成功信息(controller)。

#### 获取用户列表 | /user/listUser

功能：获取用户列表。

业务实现要点：查询数据要连表查询，要去权限表把权限也查出来。

代码执行流程：调用service层在数据库读(service)→返回读取结果(controller)。

#### 新增用户 | /user/createUser

功能：新增用户。

边界情况：

- 用户权限不能为super。
- 不能和已经存在了的名称冲突。

代码执行流程：调用service层在数据库增(service)→返回成功信息(controller)。

#### 编辑用户 | /user/updateUser

功能：修改用户信息。

边界情况：

- 防止super权限的扩散：不能将用户的权限编辑为super，通过校验请求参数实现。
- 防止super用户被篡改权限：通过if条件句判断，在请求参数包含对权限的修改的情况下，在数据库语句中通过where子句忽略掉所有用户为根用户的情况(即role=0)。从效果上看，含修改根用户权限的操作会被忽略。
- 不能和已经存在了的名称冲突。

业务要点：

1. 对某子用户密码的修改，意味着该用户先前登录状态的失效。所以这种情形事实上伴随了两个无法整合在一起的数据库操作：更新用户信息；判断，若存在密码修改，则还需将该用户记录的expire字段设置为当前时间。

   为了确保这两件事儿的一致性，需要封装进事务。

代码执行流程：调用service层在数据库改(service)→返回成功信息(controller)。

#### 删除指定用户 | /user/delUser

功能：删除指定名称用户。

边界情况：

- 不能删除根用户/超管。通过参数校验、数据库where字句两重过滤。

代码执行流程：调用service层在数据库删(service)→返回读取结果(controller)。