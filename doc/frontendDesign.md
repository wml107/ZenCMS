# 视图层界面设计



# 服务端响应处理

根据Api文档中提到的，有关前后端如何就响应体相互配合的分析，我希望客户端尽可能少的接入到对响应体的识别、判断中，尽可能拿到响应体之后以一种统一的策略去使用，所以对响应体的处理如下：

- 对于请求发生错误，状态码非2xx的情况，有拦截器集中根据接口文档的定义来处理。
- 对于请求成功的情况，如果不是一定要针对响应的具体细分情形做出反应，则尽量不去识别状态码，不去识别到底是哪一种情形，而是直接把响应体中的message放在提示中，告知用户。

# 浏览网站内容的前台设计



# 管理网站的控制台设计

## 权限、用户管理

### 数据模型

在cookie中储存token，字段为Authorization。

在store中储存以下状态：

- Account
  - id
  - username
  - role 角色
  - claims 权限列表
- User[]
  - id
  - username
  - role
- Role[]
  - id
  - rolename
  - claims

### 各功能设计

#### 用户登录

- 用户事件/视图层：

  用表单中的值作为参数，调用login action → 根据返回值弹出提示，若成功则跳转路由。

- 数据层：

  调用api层请求服务端 → 成功则将账户信息更新到数据层 → 将调用结果返回。

- 网络接口(api)层：

  发送请求并将结果返回。

#### 特定功能检查登录状态、所需要权限

这种权限校验体现在多个场景：

- 每一次页面跳转时，在cookie中检查当前是否还具备token，如果令牌已经没了，则跳转至登录页。

  在路由层，通过路由守卫实现。

- 每一次收到服务端的响应时，对于未登录-401错误，清空cookie中提示用户并跳转路由至登录页；对于权限不足-403错误，需提示用户。

  在网络接口层，响应拦截器中实现。

- 对于需求特定权限才能管理的事项，经过判断后，若不具备权限，则不展示数据、不跳转路由。

  在数据层、视图层、路由中实现。
  
  前者容易实现，视图层直接根据数据层数据进行条件渲染。
  
  后者可以通过路由守卫来实现，将数据层账户中的权限列表与路由元数据中的所需权限比对来确认是否具有权限，若不具备则重定向至上一级路由。<br>但这种方案存在一种问题/缺陷，目前仍未有效解决：路由跳转的阻止和用户权限的判断，在刚刚进入应用的情形是天然矛盾的。因为要先拿到用户信息，才能判断权限，最后决定是否阻止跳转。但如果用户不是在使用中跳转，而是一开始从输入网址的时候，那么路由进入，就注定是先于用户登录信息的获取。这个时候自动登录还没开始执行，路由守卫就开始判断了。这种情形就只有两种一刀切策略可选，要么就是默认拥有权限，在没有登录信息的时候放行全部路由，这显然是有问题的；另一种就是默认什么权限也没有，对需要权限的页面进行拦截跳转回上一级。<br>这就带来了一个副作用，一个有权限的用户在使用权限页时刷新，因为权限的判断先于账户信息的获取，被默认了没有权限，刷新的结果必然是页面跳转到了上一级。用户需要在导航栏额外点一下才能回到之前的位置。

#### 自动登录

自动登录分两方面：

- 初入应用时，向服务端请求检验token有效性并获取账户信息。

  - 用户事件/视图层：

    在Vue App的生命周期钩子中绑定方法——在应用加载之初若cookie中有token，则调用autoLogin action。

    > 这部分的逻辑写在总入口、VueApp中，而不是User的视图层、也不是User的子视图Account，写在应用入口里才能在应用启动之时完成自动登录，否则就是这些子组件的生命周期，要等切换到子组件的时候，才会触发事件，进行自动登录。

    > 除此之外不需要做任何事情，因为这个功能不涉及用户操作，是应用自发行为，成功了不会有任何后续处理，失败了则会如上一个鉴权功能提到的，被响应拦截器捕获到这种失败，自动跳转到登录页。

  - 数据层：

    调用api层请求服务端 → 成功则将账户信息更新到数据层。

  - 网络接口层：

    发送网络请求并将结构返回。

- 每次发送任何请求，携带之前手动登录的认证信息(token)。

  在网络接口层，通过全局的请求拦截器实现。在cookie中读取token并放入请求头中。

#### 退出登录

- 用户事件/视图层：

  调用quit action→根据返回值若执行成功，则跳转路由到登录页。

- 数据层：

  调用api层请求服务端→成功则清空数据层账户信息 → 将结果返回。

- 网络接口层：

  发送请求并将结果返回。

#### 密码修改

- 用户事件/视图层：

  以表单中数据作为参数，调用passwordUpdate action → 成功则提示用户。

- 数据层：

  调用api层请求服务端→将结果返回。

- 网络接口层：

  发送请求并将结果返回。

#### 获取角色列表

- 用户事件/视图层：

  两种该动作的起点：1.每次进入该功能对应子页面时，在触发的mounted事件中执行；2.用户点击刷新按钮刷新数据执行→调用listRole action。

- 数据层：

  调用api层请求服务端→成功则将数据更新到数据层→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 添加角色

- 用户事件、视图层：

  用户点击新增按钮弹出表单(收起表单时自动清空)，填写后提交表单→表单校验(角色名不能为空、super)→调用createRole action→若执行成功：清空表单→调用listRole action刷新数据→收起表单弹窗。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 修改角色

- 用户事件、视图层：

  用户点击编辑按钮弹出表单(按要编辑的条目有原数据填充表单)，填写后提交表单→表单校验(角色名不能为空、super)→调用updateRole action→若执行成功调用listRole action刷新数据→收起表单弹窗。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 删除角色

- 用户事件/视图层：

  用户点击删除按钮→获取被删除条目标识→调用delRole action→调用listRole action刷新数据。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 获取用户列表

- 用户事件/视图层：

  两种该动作的起点：1.每次进入该功能对应子页面时，在触发的mounted事件中执行；2.用户点击刷新按钮刷新数据执行→调用listUser action。

- 数据层：

  调用api层请求服务端→成功则将数据更新到数据层→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 删除用户

- 用户事件/视图层：

  用户点击删除按钮→校验确定要删除的用户不是根用户/超管→调用delUser action→调用listUser action刷新数据。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。
