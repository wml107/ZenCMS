# 视图层界面设计



# 服务端响应处理

根据Api文档中提到的，有关前后端如何就响应体相互配合的分析，我希望客户端尽可能少的接入到对响应体的识别、判断中，尽可能拿到响应体之后以一种统一的策略去使用，所以对响应体的处理如下：

- 对于请求发生错误，状态码非2xx的情况，有拦截器集中根据接口文档的定义来处理。
- 对于请求成功的情况，如果不是一定要针对响应的具体细分情形做出反应，则尽量不去识别状态码，不去识别到底是哪一种情形，而是直接把响应体中的message放在提示中，告知用户。

# 浏览网站内容的前台设计



# 管理网站的控制台设计

## 权限、用户管理

### 数据模型

在cookie中储存token，字段为Authorization。

在store中储存以下状态：

- Account
  - id
  - username
  - role 角色id
  - rolename 角色名
  - claims 权限列表
- User[]
  - id
  - username
  - role 角色id
  - rolename 角色名
  - claims 权限列表
  - expire 过期时间：一个时间戳，含义为在这个时间以前签发的token无效/上一次登录或修改密码的时间。如果某个用户从未登录，是个新建的token，该值则为0。
- Role[]
  - id
  - rolename
  - claims

### 各功能设计

#### 用户登录

- 用户事件/视图层：

  用表单中的值作为参数，调用login action → 根据返回值弹出提示，若成功则跳转路由。

- 数据层：

  调用api层请求服务端 → 成功则将账户信息更新到数据层 → 将调用结果返回。

- 网络接口(api)层：

  发送请求并将结果返回。

#### 特定功能检查登录状态、所需要权限

这种权限校验体现在多个场景：

- 每一次页面跳转时，在cookie中检查当前是否还具备token，如果令牌已经没了，则跳转至登录页。

  在路由层，通过路由守卫实现。

- 每一次收到服务端的响应时，对于未登录-401错误，清空cookie中提示用户并跳转路由至登录页；对于权限不足-403错误，需提示用户。

  在网络接口层，响应拦截器中实现。

- 对于需求特定权限才能管理的事项，经过判断后，若不具备权限，则不展示数据、不跳转路由。

  在数据层、视图层、路由中实现。
  
  前者容易实现，视图层直接根据数据层数据进行条件渲染。
  
  后者可以通过路由守卫来实现，将数据层账户中的权限列表与路由元数据中的所需权限比对来确认是否具有权限，若不具备则重定向至上一级路由。<br>但这种方案存在一种问题/缺陷，目前仍未有效解决：路由跳转的阻止和用户权限的判断，在刚刚进入应用的情形是天然矛盾的。因为要先拿到用户信息，才能判断权限，最后决定是否阻止跳转。但如果用户不是在使用中跳转，而是一开始从输入网址的时候，那么路由进入，就注定是先于用户登录信息的获取。这个时候自动登录还没开始执行，路由守卫就开始判断了。这种情形就只有两种一刀切策略可选，要么就是默认拥有权限，在没有登录信息的时候放行全部路由，这显然是有问题的；另一种就是默认什么权限也没有，对需要权限的页面进行拦截跳转回上一级。<br>这就带来了一个副作用，一个有权限的用户在使用权限页时刷新，因为权限的判断先于账户信息的获取，被默认了没有权限，刷新的结果必然是页面跳转到了上一级。用户需要在导航栏额外点一下才能回到之前的位置。

#### 自动登录

自动登录分两方面：

- 初入应用时，向服务端请求检验token有效性并获取账户信息。

  - 用户事件/视图层：

    在Vue App的生命周期钩子中绑定方法——在应用加载之初若cookie中有token，则调用autoLogin action。

    > 这部分的逻辑写在总入口、VueApp中，而不是User的视图层、也不是User的子视图Account，写在应用入口里才能在应用启动之时完成自动登录，否则就是这些子组件的生命周期，要等切换到子组件的时候，才会触发事件，进行自动登录。

    > 除此之外不需要做任何事情，因为这个功能不涉及用户操作，是应用自发行为，成功了不会有任何后续处理，失败了则会如上一个鉴权功能提到的，被响应拦截器捕获到这种失败，自动跳转到登录页。

  - 数据层：

    调用api层请求服务端 → 成功则将账户信息更新到数据层。

  - 网络接口层：

    发送网络请求并将结构返回。

- 每次发送任何请求，携带之前手动登录的认证信息(token)。

  在网络接口层，通过全局的请求拦截器实现。在cookie中读取token并放入请求头中。

#### 退出登录

- 用户事件/视图层：

  调用quit action→根据返回值若执行成功，则跳转路由到登录页。

- 数据层：

  调用api层请求服务端→成功则清空数据层账户信息 → 将结果返回。

- 网络接口层：

  发送请求并将结果返回。

#### 密码修改

- 用户事件/视图层：

  表单校验(密码不能为空)→以表单中数据作为参数，调用passwordUpdate action → 成功则提示用户并清空表单。

- 数据层：

  调用api层请求服务端→将结果返回。

- 网络接口层：

  发送请求并将结果返回。

#### 获取角色列表

- 用户事件/视图层：

  两种该动作的起点：1.每次进入该功能对应子页面时，在触发的mounted事件中执行；2.用户点击刷新按钮刷新数据执行→调用listRole action。

- 数据层：

  调用api层请求服务端→成功则将数据更新到数据层→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 添加角色

- 用户事件/视图层：

  用户点击新增按钮弹出表单(收起表单时自动清空)，填写后提交表单→表单校验(角色名不能为空、super)→调用createRole action→若执行成功：清空表单→调用listRole action刷新数据→收起表单弹窗。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 编辑角色

- 用户事件/视图层：

  用户点击编辑按钮弹出表单(按要编辑的条目有原数据填充表单)，填写后提交表单→表单校验(角色名不能为空、super)→调用updateRole action→若执行成功调用listRole action刷新数据→收起表单弹窗。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 删除角色

- 用户事件/视图层：

  用户点击删除按钮→获取被删除条目标识→调用delRole action→调用listRole action刷新数据。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 获取用户列表

- 用户事件/视图层：

  两种该动作的起点：1.每次进入该功能对应子页面时，在触发的mounted事件中执行；2.用户点击刷新按钮刷新数据执行→调用listUser action。

- 数据层：

  调用api层请求服务端→成功则将数据更新到数据层→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 新增用户

- 用户事件/视图层：

  用户点击新增按钮弹出表单(收起表单时自动清空)，填写后提交表单→表单校验(用户名、密码和角色不能为空，角色是以下拉菜单的形式提供的，不需要太多校验)→调用createUser action→若执行成功：清空表单→调用listUser action刷新数据→收起表单弹窗。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 编辑用户

- 用户事件/视图层：

  用户点击编辑按钮弹出表单(按要编辑的条目有原数据填充表单)，填写后提交表单→表单校验(用户名和密码不能为空、非根用户角色不能为super、根用户角色只能为super)→调用updateUser action→若执行成功调用listUser action刷新数据→收起表单弹窗。

  > 上面表单校验的后两项是选项，所以可以直接从备选项中剔除非法选项，就不用校验了：
  >
  > - 非根用户不能为super无需用表单校验实现——把选项列表设置成通过方法获取即可，将正在修改用户的角色id作为参数，如果原来角色不为super，就干脆不提供这个选项。
  > - 根用户角色不能修改——不提供这一表单项。

  表单各项选填的实现思路是，每项自动填充原信息，只要使用者不更改，点击提交，就是用和原数据一样的数据更新数据库，不加甄别使用者到底是不是选填还是填写了全部可选项。<br>但这样做对于密码项存在一个问题，密码项我们不希望自动填充，后端也根本就不会把密码发来，也没有数据让我们自动填充，并且密码项可以为空(不设密码)，这也就没办法用不填代表不修改密码。<br>这需要给密码项额外增加一个要不要修改密码的选项，但这样做表单就不太好看，不如把密码和其他信息的修改拆开实现，添加额外的按钮和表单，后面的操作还是一样调用updateUser action。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。

#### 删除用户

- 用户事件/视图层：

  用户点击删除按钮→校验确定要删除的用户不是根用户/超管→调用delUser action→调用listUser action刷新数据。

- 数据层：

  调用api层请求服务端→返回请求结果。

- 网络接口层：

  发送请求并将结果返回。
