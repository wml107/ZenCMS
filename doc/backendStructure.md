# 代码实现/结构

服务端是个典型的Nest应用，这里通过叙述在处理一条客户端请求时后端代码的执行流，向你展示后端代码的结构、以及他们是如何运作的：

### S0：main.ts 程序的发起

这是代码层面的入口，Nest应用从这里启动，在这里：

- 通过工厂方法创建Nest应用实例，将应用总模块装入；
- 装载插件（例如cookieParser）；
- 配置应用（例如客户端与静态资源入口）；

### S00：app.module.ts 应用的组织

Nest应用是由一个个业务模块构成的，然后模块之前可以嵌套，构成父子模块。这里的app.module显然就是系统的总模块，在这里引用所有具体的业务模块，然后一起导出，交给main.ts作为参数创建Nest实例。

说具体些，就是实现@Module注解，以配置的形式定义模块，有如下配置项：

- controllers：本模块的路由层，用于匹配特定的Url请求，处理参数，在这层调用业务层完成具体的操作，最后返回结果。

- providers：本模块的业务层，在这里执行具体的业务逻辑。（你可以把它等同于spring技术栈中的service层。）

- exports：这一项声明了该模块会暴露给引用它的模块的功能，通过这种手段，模块将自己的providers暴露给别的模块来调用。

- imports：导入其他模块。这里除了导入自己编写的业务模块，还可以导入一些库、依赖对应的模块，具体到本项目，导入了：

  - ORM框架，引入了TypeOrm作为持久层，用于完成数据库操作。这里不但导入，还完成了数据库的配置。

  - ServeStatic，用于暴露资源。这是一种迫不得已，又恰到好处的选择。

    说迫不得已，是因为本系统根据需求，希望暴露两处静态资源，一出是客户端应用本身，即前端网页、被网页引用的图片、CSS等；

    另一处则是业务层面的静态资源，即使用者编辑创作的文章、上传的插图、文件等。

    这两种资源显然在业务上不是一回事，也不可能存储在同一处。

    但问题在于，Nest本身并不具备这样分别暴露多个路径作为静态资源的能力，即S0处配置的应用静态资源入口，它只能映射到一个目录。

    而ServeStaticModule恰巧解决了这一问题，因为这个Nest提供的模块，它也能用于代理静态资源，而且它和在main.ts配置的那个还偏偏是分开的，各干各的互不干扰，恰好实现了需求。

    但这终究是迫不得已的权宜之计，明明是一类问题的处理，却偏偏写在了两处，破坏了代码的一致性，导致代码很不连贯。

- 全局绑定

  除了基本的controller、provider，还有很多其他的组成Nest应用的层（你在下面的流程中都会看到），这些层实现着某些特定功能，需要在模块、某个路由下被装入，但有些功能，是对所有请求都通用的，一个个写违背了复用原则，它们可以在全局模块中声明，声明后会被自动装入并调用，如：全局守卫、全局管道、全局拦截器、全局过滤器。

### S1：middleware 中间件

系统目前还没有使用任何中间件，代码也没有任何涉及。

### S2：guard 守卫

这一层在服务端应用中担任鉴权的功能，对应了代码中auth目录。

jwtAuth.gard.ts和local.strategy.ts定义了JWT验证和账户密码验证两种鉴权策略，<br>它们共同实现了对发来请求的用户的身份校验，确认身份信息、权限信息，在成功时将请求放行至后续流程，失败时抛出异常。

- 前者继承自jwt.strategy.ts，它又继承自passport库的jwt策略
- 后者继承自passport库的local策略

authorization.decorator.ts定义了一些装饰器，这些装饰器被各项具体的功能所使用，用来标注自己的这处调用具体需要什么权限。

auth.service.ts则是封装了一系列鉴权过程中的一些操作、方法，供上面的两个策略调用，例如校验账户密码是否正确、生成token、根据id获取用户信息、根据id获取用户权限列表、判断token是否过期。

最后它们一起作为一个模块，由auth.module.ts整合并暴露，装入nest应用，成为应用的一部分。

十分无奈的一点在于，Nest应用无法在守卫中设置响应体的cookie，所以为客户端签发、刷新token的逻辑被迫放在了接下来的拦截器中，这使得代码结构显得不那么各司其职、鉴权的代码实现的不是很连贯。

### S3： interceptor 请求拦截器

顾名思义，这层完成了请求处理的一系列前置操作，在代码的interceptor目录中实现。



目前只有一个请求拦截器：refreshToken.interceptor.ts，用于为客户端在cookie设置token。

该拦截器执行的业务本该属于守卫层，但由于技术的原因，只能放在这层(前面提过)。

即便是这样，依然有着妥协：按理说，就算放在拦截器，设置cookie也应该放在所有处理的最后，即放在响应拦截器中，毕竟这是响应的一部分，和请求根本没什么关系。更何况有时候还会在业务层涉及token的操作。但同样是由于Nest本身的特性/限制，响应拦截器里面不能设置头信息，确切的或是在handle方法之后不能再设置头信息。所以只能被迫放在请求拦截器里。

### S4：pipe 管道

管道层完成两件事：对请求参数的校验、对请求参数的转换。主要通过pipes目录中的代码实现。

本系统采用了class-validation库，这个库使得我们只需在dto中添加注解，就能完成最普遍的类型校验，也能完成一些含简单逻辑的校验。对于更负责的校验则额外手动实现。

### 业务层

此时才算完成了前置操作，进入了真正的核心业务层，执行具体的操作。对应了各个“.module”的业务目录。

在代码的实现上，业务层由一个个module构成，这些模块内包含：

- dto：建立请求参数与对象的映射，nest会将请求参数根据定义，转换至你声明好的对象。

  除此之外，还在这里添加类型注解用于参数校验。

- entities：建立数据库中模型/表与对象的映射，这里定义声明了当前模块用到的数据表以及表结构。这些entities，是框架TypeOrm完成数据库操作的载体。

- controller：如开头所述。

- provider：如开头所属。

### S5：controller 路由

它们最大的用处，就是用于匹配指定Url的请求。

在这里调用各个provider中的方法，完成具体的处理，然后再集中处理由这些方法得到的结果，根据结果做出响应。

但在这之前，还有一些事情要做，管道层只能完成普适的、最基本的、侧重类型的参数校验，但参数校验不止有类型、取值。多数情况下，参数的校验是要结合具体业务的。

### 参数校验是个麻烦事

事实上参数校验在编码实现上看，是非常不连贯的：

- 管道层有，但没办法实现全部，因为有很多参数的校验是和业务强相关的；
- 所以这些工作就被推到了路由层，结合具体的业务来校验，这依旧不是全部，因为很多参数哪怕结合业务也看不出来是否合法，要在具体的执行环节才能露出端倪；
- 所以有些时候业务层也参杂着参数校验。举几个最简单的例子：用户名重复、路径不可达、路径超出访问权限、文件名重复。但着又难以界定，因为你可以说它是用户参数非法，也可以说是业务上的逻辑错误，业务执行失败罢了。难以界定。

这就导致有关这部分再代码上看是比较乱的。

### S6：provider 业务

在业务层完成对具体请求的处理/功能的实现。



这一层中的service方法，除去抛出异常的方式，返回正常处理结果时，若执行的是某种操作，没有要返回的信息，就返回布尔值，有要返回的值，则将值返回。

> 但目前代码暂时没有按照这样的逻辑来写，现在代码中有相当一部分，是直接在业务层就生成响应体了，然后返回的是响应体。
>
> 我也是后知后觉，意识到这是一种相当糟糕的做法：因为这样做破坏了每一层的单一职责，向客户端发出响应应当是路由层的职责，不应在业务层设置响应结果的生成。这会给未来的开发埋下很多麻烦，例如路由层需要调用多个业务层方法或者业务层方法之间相互调用的情形。
>
> 这一点会逐步改正。

### S7：interceptor 响应拦截器

在controller返回响应之前，程序还需要进入响应拦截器，完成一些收尾、转换等工作，在代码的interceptor目录中实现。



目前只有一个响应拦截器：logRequest.interceptor.ts，用于记录所有请求的日志，完成业务监测。

但这依旧有着迫不得已，显然，有的请求成功了，能够被拦截器捕获并记录进日志，但是对于请求失败、抛出异常的情况，响应拦截器根本没办法捕获并将这些异常记入日志，因为Nest根本就不支持。

所以明明是一块业务(日志记录)，又被被迫分了一部分进filter层，破坏了连贯性，代码实现上显得很乱。

### S8：filter 异常过滤器

前面所有的流程中，只要出现异常、错误，不论是业务层面上因为执行失败，主动抛出给客户端的业务层面的异常；还是服务端因未知原因出现的内部错误，都不是直接将异常返回给客户端的。

在处理客户端请求的流程中，对于抛出的任何异常，都进入了异常过滤器中，由异常过滤器进行相应处理，并由异常过滤器来向调用方发送（统一格式的）响应。

Nest有自带的默认过滤器，用于针对异常信息，返回给客户端统一格式的响应，这些响应中包含异常信息。



本系统基于内置的过滤器继承实现了额外的异常过滤器：主要通过filter目录中的代码实现。

- logError.filter.ts。它作为全局过滤器，用于将请求失败的情形计入日志，和记录请求成功情形的那个响应拦截器共同记录业务日志、完成业务监测。

### utils目录

对某些可复用逻辑的封装。一般起工具作用，与业务关联不大。

从命名看，小写字母开头的，只是一个简单的方法；大写字母开头的，是有关处理一类事宜的类。

- MapSerialize.ts：完成map、Json、String之间的相互转换。
- pathAuthorityValidation.ts：校验是否有权限访问某个路径，接收两个参数，一个是授权访问的根路径，一个是要访问的路径，该方法判断后者是否超出前者。
- Response.ts：用于封装生成统一风格的响应体。并提供状态码的常量定义。都是一些有关响应的内容。

### 迫不得已的代码不连贯

这一部分是对前文某一方面的一个总结：受限于Nest本身的能力，很多时候，某一类业务要被迫分散的写在不同的层，这可能会带来阅读障碍。

- 鉴权大部分实现在了守卫，但也有一小部分实现放在了拦截器。
- 参数校验被迫分散在了管道层、路由层、业务层。
- 业务监测的实现被分散在了响应拦截器和异常过滤器中。

# 数据库

从业务内容上看，这个应用没有太过复杂的数据需要保存在数据库中，需要保存在数据库中的数据本身和涉及的操作都非常简单，所以本应用选择了SQLite作为数据库系统。
